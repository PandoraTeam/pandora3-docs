# Концепция

При разработке готовых элементов для повторного использования следует придерживаться следующих принципов:
* Открытость к добавлению новой функциональности
* Возможности изменять стандартное поведение
* Переопределение поведения предпочтительнее предоставлению настроек


## Цель проекта

Cовместить **минимализм** и **легкость повторного использования имеющегося кода**, при этом **не закрывая возможности для дальнейшей кастомизации**.

### Минимализм

Недостаток минимализма в том, что реализованной функциональности может быть недостаточно для конкретной задачи. Этот недостаток будет компенсороваться **кастомизируемостью** (возможностью надстроек).

* Увеличение быстродействия
* Уменьшение порога вхождения. Меньший объем кода уменьшает временя на понмание и рефакторинг.
* Уменьшение количества ошибок

### Повторное-использование

Повторное использование любят все, оно позволяет существенно сократь время разработки. Но бывает, что готовые решения **плохо кастомизируемы** или **громоздки** или используют **больше зависимостей чем необходимо** для своей работы. Поэтому **соблюдать** его нужно **не во вред всем остальным пунктам**.

Инструменты достижения:
* **Отказ от монолитности** в пользу **модульности** и **использования интерфейсов**.
* При разработке функциональности под конкретную задачу абстрагироваться от нее и **создать максимально типовое решение**. Или обойтись быстрым решением под задачу, и потом предоставить написание типового решения команде или сообществу. В дальнейшем можно будет заменить быстрое решение на типовое с добавлением надстройки под задачу.

### Кастомизация

Многие знают какого это, когда подходящая готовая функциональность имеет места которые хочется изменить, но разработчики не предоставили инструментов для этого. Конечно, делать максимум настроек это тупиковый путь, потому что утяжеляет решение (препятствует минимализму) и все равно что-то остается ненастраиваемым. Предпочтительнее другой способ: оставлять потенциал для изменений и надстроек, видение таких возможностей для дальнейшего роста приходит с опытом.
Инструменты достижения:
* **Расширяемость**. Использование **наследования** для **переопределения логики**. Всегда оставлять точки роста для дальнейших надстроек, продумать какие части можно вынести в отдельные методы для дальнейшего переопределения.
* Снова **модульность**. Если какая-то часть плохо подходит под задачу, ее можно заменить на другую не требуя изменений других частей что позволит обойтись минимальными затратами.
* **Переопределение шаблонов** в плагинах и виджетах (данный прием успешно используется в CMS Joomla но к сожалению ограничивается только шаблонами)

### Избежание лавинных зависимостей (Dependency-hell)

Большинству знакома эта ситуацией, когда установка небольшой библиотеки приводит к загрузке половины базовых компонентов фреймворка Symfony, даже если большая часть кода в них не будет использоваться в данном проекте. Для некоторых установка лишних зависимостей не является проблемой. Но она начинает ощущаться при возникновении конфликтов зависимотей, которых, я верю, можно избежать уменьшением количества неиспользуемых зависимостей.

Предлагаемое решение: если часть функций или классов библиотеки **A** использует **B** а другая часть использует **C**, требуется разбить библиотеку **A** на две части, каждая из которых будет иметь свои зависимости. Тогда если потребутся первая часть функций, будет загружена только используемая библиотека **B**.

Конечно в каждом конкретном случае надо разбираться отдельно. Чаще всего зависимости библиотек будут связаны по смыслу. И если появляются отклонения от данной тенденции, тогда и стоит обратить на это внимание.
